# Default values for libChart
# This is a YAML-formatted file.
# This chart is a unified library chart that consolidates application, networking, and monitoring functionality.

# ----------------------------------------------------------------------------
# Global Configuration
# ----------------------------------------------------------------------------
global:
  # name is the application name (DNS-1123 compliant, max 63 chars). Required.
  name: "app"
  # namespace is the Kubernetes namespace for all resources. Required.
  namespace: "default"
  labels:
    # partOf is the name of higher level application (e.g., "media-center"). Optional.
    partOf: ""
    # component is the workload component type (e.g., "frontend", "api", "worker"). Optional.
    component: ""
    # overrides is a map to override standard metadata labels.
    # Reserved selector labels cannot be overridden:
    # - app.kubernetes.io/name
    # - app.kubernetes.io/instance
    # Optional.
    overrides: {}

# ----------------------------------------------------------------------------
# Deployment Configuration
# ----------------------------------------------------------------------------
deployment:
  # replicas is the number of pod replicas.
  replicas: 1
  strategy:
    # type is the deployment strategy type (Recreate or RollingUpdate).
    type: Recreate
  # revisionHistoryLimit is the number of old ReplicaSets to retain.
  revisionHistoryLimit: 3

  # imagePullSecrets is the list of image pull secrets.
  imagePullSecrets: []

  # terminationGracePeriodSeconds is the pod termination grace period in seconds.
  terminationGracePeriodSeconds: 30

  # podLabels are additional labels to add to pods.
  podLabels: {}

  # podSecurityContext is the pod-level security context with secure defaults.
  podSecurityContext:
    runAsNonRoot: true
    seccompProfile:
      type: RuntimeDefault

  # defaultContainerSecurityContext is the default security context applied to all containers unless overridden.
  defaultContainerSecurityContext:
    allowPrivilegeEscalation: false
    # readOnlyRootFilesystem is enabled by default for stronger container hardening.
    # Override per container when writable filesystem is required.
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    capabilities:
      drop:
        - ALL
    seccompProfile:
      type: RuntimeDefault
    appArmorProfile:
      type: RuntimeDefault

  # --- Scheduling (all optional, omit to use Kubernetes defaults) ---
  # nodeSelector constrains pods to nodes with matching labels. Optional.
  # nodeSelector: {}
  # affinity defines pod affinity/anti-affinity rules. Optional.
  # affinity: {}
  # tolerations defines pod tolerations. Optional.
  # tolerations: []
  # topologySpreadConstraints controls how pods spread across topology domains. Optional.
  # topologySpreadConstraints: []
  # dnsPolicy sets the DNS policy for pods (ClusterFirst, Default, None, ClusterFirstWithHostNet). Optional.
  # dnsPolicy: ClusterFirst
  # enableServiceLinks controls whether service environment variables are injected. Optional.
  # enableServiceLinks: true

  # containers is a map of container definitions. Must be explicitly defined by service chart.
  # Services must define their containers explicitly, e.g.:
  # containers:
  #   radarr:
  #     image:
  #       repository: ghcr.io/runlix/radarr
  #       tag: "latest"
  #       pullPolicy: IfNotPresent
  #     ports:
  #       - name: http
  #         containerPort: 8080
  #         protocol: TCP
  #     lifecycle:
  #       preStop:
  #         exec:
  #           command: ["/bin/sh", "-c", "sleep 15"]
  containers:
    placeholder:
      enabled: false
      image:
        repository: changeme
        tag: changeme

  # initContainers is a map of init container definitions.
  # example-init:
  #   image:
  #     repository: busybox
  #     tag: latest
  #   command: ['sh', '-c', 'echo init']
  initContainers: {}

# ----------------------------------------------------------------------------
# Feature: Persistence
# ----------------------------------------------------------------------------
persistence:
  # enabled is the feature flag to enable persistence (PVC + volumes).
  enabled: false

  # claims is a dictionary of PVC definitions.
  # Each key is the claim name suffix (full name: {global.name}-{key})
  # Chart will generate PVC resources for each entry
  # Example:
  # config:
  #   size: 1Gi
  #   storageClass: "local-path"  # REQUIRED - storage class name
  #   accessMode: ReadWriteOnce
  #   retain: true  # Retain PVC on release deletion (adds helm.sh/resource-policy: keep)
  claims: {}

  # volumes is a list of volume definitions (nfs, hostPath, emptyDir, secret, configMap, etc).
  # These volumes will be added to the Deployment's spec.template.spec.volumes
  # For PVC volumes, reference the claim name: {global.name}-{claimKey}
  # Example:
  # - name: config
  #   persistentVolumeClaim:
  #     claimName: "{global.name}-config"
  # - name: media
  #   nfs:
  #     server: snorlax.orhayoun.com
  #     path: /mnt/vol1/media-center/media
  # - name: downloads
  #   nfs:
  #     server: snorlax.orhayoun.com
  #     path: /mnt/vol1/media-center/downloads
  # - name: secrets
  #   secret:
  #     secretName: my-secret
  volumes: []

# ----------------------------------------------------------------------------
# Feature: ConfigMap
# ----------------------------------------------------------------------------
# configMap is a dictionary of ConfigMap definitions. Each key becomes a resource name suffix.
# Full resource name: {global.name}-{key}
configMap:
  # componentLabel overrides the app.kubernetes.io/component label for all ConfigMaps (default: "config").
  componentLabel: ""
  # additionalLabels are extra labels applied to all ConfigMap resources.
  additionalLabels: {}
  # Example:
  # app-config:
  #   data:
  #     config.yaml: |
  #       key: value
  #     setting: "value"
  #   annotations: {}
  # other-config:
  #   data:
  #     env: "production"
  items: {}

# ----------------------------------------------------------------------------
# Feature: Observability
# ----------------------------------------------------------------------------
metrics:
  # enabled is the feature flag to enable metrics collection (ServiceMonitor + PrometheusRule).
  enabled: false

  # serviceMonitor is the ServiceMonitor configuration.
  serviceMonitor:
    # enabled controls ServiceMonitor resource creation.
    enabled: true
    # port is the metrics container port number (for reference).
    port: 9100
    # portName is the named port on the Service that the ServiceMonitor endpoint targets.
    portName: "metrics"
    # interval is the ServiceMonitor scrape interval.
    interval: "10s"
    # scrapeTimeout is the ServiceMonitor scrape timeout.
    scrapeTimeout: "5s"
    # path is the metrics endpoint path (e.g., "/metrics"). Optional.
    path: ""
    # honorLabels controls whether to honor labels from target. Optional.
    honorLabels: false

    # Selector for ServiceMonitor spec
    # Allows customizing which services are selected for scraping
    # Supports both matchLabels and matchExpressions
    # Example with matchLabels:
    #   matchLabels:
    #     app.kubernetes.io/name: "my-app"
    #     app.kubernetes.io/instance: "my-release"
    # Example with matchExpressions:
    #   matchExpressions:
    #     - key: app.kubernetes.io/name
    #       operator: In
    #       values: ["app1", "app2"]
    # If not provided, defaults to standard selectorLabels helper
    selector: {}

    # Namespace selector for ServiceMonitor spec
    # Allows selecting namespaces to scrape from
    # Example:
    #   matchNames:
    #     - default
    #     - monitoring
    namespaceSelector: {}

    # Relabelings - Prometheus relabel configs (applied before scraping)
    # Full Prometheus relabeling configuration format
    # Example:
    #   - action: replace
    #     sourceLabels: [__meta_kubernetes_pod_name]
    #     targetLabel: pod_name
    relabelings: []

    # Metric relabelings - Prometheus relabel configs (applied after scraping)
    # Full Prometheus relabeling configuration format
    # Example:
    #   - action: replace
    #     targetLabel: service
    #     replacement: radarr
    #   - action: replace
    #     targetLabel: component
    #     replacement: media-center
    metricRelabelings: []

  # PrometheusRule Configuration
  prometheusRule:
    enabled: true  # Enable PrometheusRule resource creation
    # Custom Alert Rules
    # Define service-specific alerts here as an array of PrometheusRule alert definitions
    # Example:
    # - alert: ServiceDown
    #   expr: service_system_status == 0
    #   for: 5m
    #   labels:
    #     severity: critical
    #   annotations:
    #     summary: "Service is down"
    #     description: "Service system status is 0 (unhealthy) for more than 5 minutes."
    rules: []

  # Grafana Configuration
  grafana:
    enabled: false  # Feature flag - enable GrafanaDashboard CRD generation
    # Global instance selector - applied to all dashboards unless overridden per-dashboard
    # This selects which Grafana instance(s) should receive the dashboards
    # Example:
    #   matchLabels:
    #     dashboards: "grafana-a"
    # Or with matchExpressions:
    #   matchExpressions:
    #     - key: dashboards
    #       operator: In
    #       values: ["grafana-a", "grafana-b"]
    instanceSelector: {}
    dashboard:
      enabled: false  # Enable GrafanaDashboard CRD generation
      # Dictionary of dashboard items - each key becomes a resource name suffix
      # Each item will generate a GrafanaDashboard CRD named: {global.name}-{key}
      items: {}
        # Example:
        # my-dashboard:
        #   name: "my-dashboard"  # Optional - dashboard name (defaults to key)
        #   # Option 1: Inline JSON content (string or map)
        #   json: |
        #     {
        #       "id": null,
        #       "title": "My Dashboard",
        #       "tags": [],
        #       "timezone": "browser",
        #       "schemaVersion": 17,
        #       "version": 0,
        #       "panels": []
        #     }
        #   # Option 2: Load JSON from file (relative to dashboards/ directory)
        #   # file: "my-dashboard.json"
        #   # Optional: Override global instanceSelector for this dashboard
        #   instanceSelector:
        #     matchLabels:
        #       dashboards: "specific-grafana"
        #   # Optional: Folder assignment (only one of folder, folderUID, or folderRef)
        #   # folder: "My Folder"  # Folder title
        #   # folderUID: "folder-uid"  # Folder UID
        #   # folderRef: "grafana-folder-resource"  # GrafanaFolder resource name
        #   # Optional: Required plugins
        #   plugins: []
        #     # - name: "grafana-piechart-panel"
        #     #   version: "1.6.2"
        #   # Optional: Allow cross-namespace import (boolean)
        #   allowCrossNamespaceImport: false
        #   # Optional: Metadata annotations
        #   annotations: {}

# ----------------------------------------------------------------------------
# Service Account
# ----------------------------------------------------------------------------
serviceAccount:
  # create controls whether to create a service account.
  create: true
  # automount controls service account token automounting. Disabled by default for security.
  # Enable only if service needs Kubernetes API access.
  automount: false
  # annotations are service account annotations.
  annotations: {}
  # name is the service account name (defaults to chart name if empty).
  name: ""

# ----------------------------------------------------------------------------
# Feature: Secrets
# ----------------------------------------------------------------------------
secrets:
  # enabled is the feature flag to enable secrets management.
  enabled: false
  sealedSecret:
    # enabled is the feature flag to enable SealedSecret generation.
    enabled: false
    # items is a dictionary of sealed secret definitions. Each key is the secret name.
    items: {}
      # Example:
      # my-secret:
      #   data:
      #     username: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEQAx...
      #     password: AgBy3i4OJSWK+PiTySYZZA9rO43cGDEQAx...
      #   annotations:
      #     sealedsecrets.bitnami.com/managed: "true"
      #   labels:
      #     app.kubernetes.io/component: "secrets"
      #   templateAnnotations:
      #     sealedsecrets.bitnami.com/cluster-wide: "true"
      #   type: Opaque  # Optional - defaults to "Opaque"

# ----------------------------------------------------------------------------
# Pod disruption budget configuration
# ----------------------------------------------------------------------------
podDisruptionBudget:
  # enabled controls whether to create a PodDisruptionBudget. Disabled by default.
  enabled: false
  # minAvailable is the minimum available pods. Mutually exclusive with maxUnavailable.
  minAvailable: null
  # maxUnavailable is the maximum unavailable pods. Mutually exclusive with minAvailable.
  maxUnavailable: null
  # unhealthyPodEvictionPolicy is the eviction policy ("IfHealthyBudget" or "AlwaysAllow"). K8s 1.26+. Optional.
  unhealthyPodEvictionPolicy: null

network:
  # enabled is the feature flag to enable networking features.
  enabled: true
  httpRoute:
    # enabled is the feature flag to enable HTTPRoute (Gateway API + security policies).
    enabled: false
    # host is the hostname for HTTPRoute. Required when httpRoute.enabled is true.
    host: ""
    # port is the service port to route to.
    port: 80
    gateway:
      # name is the gateway name. Required when httpRoute.enabled is true.
      name: ""
      # namespace is the gateway namespace. Required when httpRoute.enabled is true.
      namespace: ""
    # routes is the HTTPRoute configuration for different listeners.
    # Each route can bind to a listener by sectionName, port, or both
    # Rules support template strings that will be evaluated at render time
    routes:
      # Main Application Route (HTTPS)
      - name: route
        enabled: true
        listener:
          sectionName: https
          # port: 443  # Can be used instead of or in addition to sectionName
        rules:
          - matches:
              - path:
                  type: PathPrefix
                  value: /
            backendRefs:
              - name: "{{ .Values.global.name }}"
                port: "{{ .Values.network.httpRoute.port }}"
                weight: 100
                group: ""
                kind: Service

      # HTTP Redirect Route
      - name: http-redirect
        enabled: true
        listener:
          sectionName: http
        rules:
          - matches:
              - path:
                  type: PathPrefix
                  value: /
            filters:
              - type: RequestRedirect
                requestRedirect:
                  scheme: https
                  statusCode: 301
    # Auto-generates:
    # 1. HTTPRoute (Gateway API)
    # 2. AuthorizationPolicy (ingress source)
    # 3. NetworkPolicy (ingress rule)
  # NetworkPolicy Configuration - Multiple policies support
  # Map of policy name suffix to NetworkPolicy configuration
  # Each policy will be named: {global.name}-{key}
  # The key must be explicitly defined (no empty keys allowed)
  # Full NetworkPolicy spec (excluding podSelector, which is auto-injected)
  # The template handles: apiVersion, kind, metadata, podSelector
  # You provide: enabled, policyTypes, ingress, egress
  #
  # IMPORTANT:
  # - The template does NOT inject any default ingress/egress rules.
  # - If you enable NetworkPolicy for a service, you MUST explicitly include:
  #   - DNS egress (UDP/TCP 53) if the workload needs DNS
  #   - Kube API egress (typically 10.43.0.1:6443) if the workload needs it
  #   - Any Istio ambient mesh ports (e.g. HBONE 15008) you require
  # - `ports` MUST be valid NetworkPolicyPort objects (no bare ints).
  #
  # Template variables can be used in the spec YAML:
  # {global.name}, {service.port}, {metrics.serviceMonitor.port}, {httpRoute.gateway.namespace}, {httpRoute.gateway.name}
  #
  networkPolicy:
    items: {}
      # Example - Single policy:
      # main:
      #   enabled: true
      #   policyTypes:
      #     - Ingress
      #     - Egress
      #   ingress:
      #     - from:
      #         - namespaceSelector:
      #             matchLabels:
      #               kubernetes.io/metadata.name: "{httpRoute.gateway.namespace}"
      #           podSelector:
      #             matchLabels:
      #               app.kubernetes.io/name: "{httpRoute.gateway.name}"
      #       ports:
      #         - protocol: TCP
      #           port: "{service.port}"
      #         - protocol: TCP
      #           port: 15008
      #   egress:
      #     - to:
      #         - namespaceSelector:
      #             matchLabels:
      #               kubernetes.io/metadata.name: kube-system
      #       ports:
      #         - protocol: UDP
      #           port: 53
      #         - protocol: TCP
      #           port: 53
      #     - to:
      #         - ipBlock:
      #             cidr: 0.0.0.0/0
      #             except:
      #               - 10.42.0.0/16
      #               - 10.43.0.0/16
      #       ports:
      #         - protocol: TCP
      #           port: 80
      #         - protocol: TCP
      #           port: 443
      #
      # Example - Multiple policies:
      # ingress:
      #   enabled: true
      #   policyTypes:
      #     - Ingress
      #   ingress:
      #     - from:
      #         - namespaceSelector:
      #             matchLabels:
      #               kubernetes.io/metadata.name: istio-system
      #       ports:
      #         - protocol: TCP
      #           port: 8080
      # egress:
      #   enabled: true
      #   policyTypes:
      #     - Egress
      #   egress:
      #     - to:
      #         - namespaceSelector:
      #             matchLabels:
      #               kubernetes.io/metadata.name: kube-system
      #       ports:
      #         - protocol: UDP
      #           port: 53
  # services is the Service configuration supporting multiple services.
  # Map of service name suffix to service configuration
  # Each service will be named: {global.name}-{key}
  services:
    items: {}
      # Example - Single service:
      # main:
      #   enabled: true
      #   type: ClusterIP
      #   ports:
      #     http:
      #       port: 80
      #       targetPort: 8080
      #       protocol: TCP
      #   annotations: {}
      #
      # Example - Multiple services:
      # main:
      #   enabled: true
      #   type: ClusterIP
      #   ports:
      #     http:
      #       port: 80
      #       targetPort: 8080
      #       protocol: TCP
      # metrics:
      #   enabled: true
      #   type: ClusterIP
      #   ports:
      #     metrics:
      #       port: 9100
      #       targetPort: 9100
      #       protocol: TCP
  istio:
    # enabled is the feature flag to enable Istio features.
    enabled: true
    # authorizationPolicy is the AuthorizationPolicy configuration.
    # Map of policy name suffix to AuthorizationPolicy configuration
    # Each policy will be named: {global.name}-{key}
    authorizationPolicy:
      # enabled is the feature flag to enable AuthorizationPolicy generation.
      enabled: false
      items: {}
        # Example - Single policy:
        # default:
        #   enabled: true
        #   action: ALLOW
        #   rules:
        #     - from:
        #         - source:
        #             principals:
        #               - "cluster.local/ns/{httpRoute.gateway.namespace}/sa/{httpRoute.gateway.name}-istio"
        #       to:
        #         - operation:
        #             ports: ["{service.port}"]
        #
        # Example - Multiple policies:
        # ingress:
        #   enabled: true
        #   action: ALLOW
        #   rules:
        #     - from:
        #         - source:
        #             principals:
        #               - "cluster.local/ns/istio-system/sa/shared-platform-gateway-istio"
        #       to:
        #         - operation:
        #             ports: ["8080"]
        # prometheus:
        #   enabled: true
        #   action: ALLOW
        #   rules:
        #     - from:
        #         - source:
        #             principals:
        #               - "cluster.local/ns/monitoring/sa/prometheus-kube-prometheus-prometheus"
        #       to:
        #         - operation:
        #             ports: ["{metrics.serviceMonitor.port}"]
    # destinationRule is the DestinationRule configuration (Circuit Breaker).
    # Provides connection pooling and outlier detection to prevent cascading failures
    destinationRule:
      # enabled is the feature flag to enable DestinationRule. Opt-in, disabled by default.
      enabled: false
      # host is the destination service hostname. Required when enabled.
      host: ""
      trafficPolicy:
        connectionPool:
          tcp:
            maxConnections: 100  # Maximum number of TCP connections
          http:
            http1MaxPendingRequests: 10  # Max pending HTTP/1.1 requests
            http2MaxRequests: 100  # Max concurrent HTTP/2 requests
            maxRequestsPerConnection: 2  # Max requests per HTTP/2 connection
        outlierDetection:
          consecutive5xxErrors: 5  # Eject after N consecutive 5xx errors
          interval: 30s  # Time between ejection scans
          baseEjectionTime: 30s  # Base time a host is ejected
          maxEjectionPercent: 50  # Maximum percentage of hosts ejected
